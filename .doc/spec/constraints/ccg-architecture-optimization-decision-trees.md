# CCG 架构优化可视化决策树

**生成时间**：2026-02-13
**关联文件**：
- 约束集：ccg-architecture-optimization-constraints.md
- 提案：ccg-architecture-optimization-proposal.md
- 摘要：ccg-architecture-optimization-summary.md

---

## 1. 智能路由决策树

```
用户输入任务
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 1：任务类型识别                                      │
└─────────────────────────────────────────────────────────┘
    │
    ├─ 是否需要代码变更？
    │   ├─ 否 → [路径 A] 主代理直接执行
    │   │         示例：ccg:enhance, ccg:analyze（纯分析）
    │   │         成本：1x
    │   │
    │   └─ 是 ↓
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 2：复杂度评估                                        │
└─────────────────────────────────────────────────────────┘
    │
    ├─ 涉及多少个文件？
    │   ├─ 1-3 个文件 → [路径 B] 主代理或 Subagent
    │   │                 ├─ 逻辑简单 → 主代理直接执行
    │   │                 │   示例：修改单个配置文件
    │   │                 │   成本：1x
    │   │                 │
    │   │                 └─ 逻辑复杂 → Subagent 执行
    │   │                     示例：ccg:plan → ccg:execute
    │   │                     成本：1x
    │   │
    │   └─ 4+ 个文件 ↓
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 3：协作需求分析                                      │
└─────────────────────────────────────────────────────────┘
    │
    ├─ 文件间是否需要接口对齐？
    │   ├─ 否 → [路径 C] Subagents 并行执行
    │   │         示例：独立模块的并行开发
    │   │         成本：1x（多个 Subagent 并行）
    │   │
    │   └─ 是 ↓
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 4：实时协商需求                                      │
└─────────────────────────────────────────────────────────┘
    │
    ├─ 是否需要实时协商接口？
    │   ├─ 否 → [路径 D] 主代理规划 → Subagents 执行
    │   │         示例：接口已明确，只需按计划实施
    │   │         成本：1x
    │   │
    │   └─ 是 ↓
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 步骤 5：成本预算评估                                      │
└─────────────────────────────────────────────────────────┘
    │
    ├─ Token 预算是否充足？
    │   ├─ 是 → [路径 E] Agent Teams 执行
    │   │         示例：ccg:team-exec（前后端联调）
    │   │         成本：~7x
    │   │         优势：实时协商、质量高
    │   │
    │   └─ 否 → [路径 F] 混合策略（侦察-突击-扫尾）
    │             示例：ccg:workflow（6 阶段）
    │             成本：2-3x
    │             优势：成本与质量平衡
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 执行路径总结                                              │
├─────────────────────────────────────────────────────────┤
│ 路径 A：主代理直接执行（1x）                              │
│ 路径 B：主代理或 Subagent（1x）                          │
│ 路径 C：Subagents 并行（1x）                             │
│ 路径 D：主代理规划 + Subagents（1x）                     │
│ 路径 E：Agent Teams（~7x）                               │
│ 路径 F：混合策略（2-3x）                                  │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 任务规划职责决策树

```
任务输入
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 问题 1：任务复杂度如何？                                  │
└─────────────────────────────────────────────────────────┘
    │
    ├─ 简单（1-3 个步骤）
    │   └─→ 规划者：主代理
    │       执行者：主代理
    │       示例：ccg:enhance
    │
    ├─ 中等（4-10 个步骤）
    │   │
    │   ├─ 问题 2：是否需要外部模型视角？
    │   │   ├─ 否 → 规划者：主代理
    │   │   │       执行者：Subagent
    │   │   │       示例：ccg:plan → ccg:execute
    │   │   │
    │   │   └─ 是 → 规划者：Subagent（调用外部模型）
    │   │           执行者：主代理
    │   │           示例：ccg:analyze
    │   │
    │   └─→ 成本：1x
    │
    └─ 高（10+ 个步骤）
        │
        ├─ 问题 3：是否需要执行者参与规划？
        │   ├─ 否 → 规划者：主代理或 Subagent
        │   │       执行者：Agent Teams
        │   │       示例：ccg:team-plan → ccg:team-exec
        │   │       成本：规划 1x + 执行 7x
        │   │
        │   └─ 是 → 规划者：Agent Teams Lead
        │           执行者：Agent Teams Builders
        │           示例：Team 内部规划并执行
        │           成本：~7x（规划和执行都在 Team 内）
        │           ⚠️ 注意：规划阶段不需要 P2P 通信，
        │              建议使用"规划者在 Team 外"方案
        │
        └─ 问题 4：是否需要分阶段执行？
            ├─ 否 → 使用上述方案
            │
            └─ 是 → 规划者：混合（每阶段独立规划）
                    执行者：混合（侦察-突击-扫尾）
                    示例：ccg:workflow
                    成本：2-3x
```

---

## 3. Subagents vs Agent Teams 选择决策树

```
任务特征分析
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 核心问题：工作者之间是否需要互相通信？                     │
└─────────────────────────────────────────────────────────┘
    │
    ├─ 否 → ✅ 使用 Subagents
    │         理由：
    │         - 成本低（1x）
    │         - 架构简单
    │         - 结果压缩回传
    │         适用场景：
    │         - 独立任务
    │         - 低耦合模块
    │         - 只关心结果
    │
    └─ 是 ↓
        │
        ▼
    ┌─────────────────────────────────────────────────────┐
    │ 问题 1：是否需要接口契约实时对齐？                    │
    │ （如前后端 API 联调、OAuth 集成）                     │
    └─────────────────────────────────────────────────────┘
        │
        ├─ 是 → ✅ 使用 Agent Teams
        │         理由：
        │         - 支持 P2P 通信
        │         - 实时协商接口
        │         - 减少返工
        │
        └─ 否 ↓
            │
            ▼
        ┌─────────────────────────────────────────────────┐
        │ 问题 2：是否需要多假设并行验证？                  │
        │ （如复杂调试、多方案对比）                        │
        └─────────────────────────────────────────────────┘
            │
            ├─ 是 → ✅ 使用 Agent Teams
            │         理由：
            │         - Teammates 互相挑战
            │         - 收敛到最优方案
            │         - 质量高
            │
            └─ 否 ↓
                │
                ▼
            ┌─────────────────────────────────────────────┐
            │ 问题 3：是否需要实时可观测每个工作者进度？    │
            └─────────────────────────────────────────────┘
                │
                ├─ 是 → ✅ 使用 Agent Teams
                │         理由：
                │         - 白盒可观测
                │         - 用户可介入
                │         - 共享任务列表
                │
                └─ 否 ↓
                    │
                    ▼
                ┌─────────────────────────────────────────┐
                │ 问题 4：预算是否敏感？                    │
                └─────────────────────────────────────────┘
                    │
                    ├─ 是 → ✅ 使用 Subagents
                    │         理由：
                    │         - 成本低（1x vs 7x）
                    │         - 只关心结果
                    │         - 黑盒执行
                    │
                    └─ 否 → ✅ 使用 Agent Teams
                              理由：
                              - 预算充足
                              - 追求质量
                              - 需要协作
```

---

## 4. 命令层存在必要性决策树

```
架构设计决策
    │
    ▼
┌─────────────────────────────────────────────────────────┐
│ 问题：是否保留命令层？                                    │
└─────────────────────────────────────────────────────────┘
    │
    ├─ 方案 A：保留命令层
    │   │
    │   ├─ 优势：
    │   │   ✅ 符合渐进式披露原则
    │   │   ✅ 用户友好（/ccg:workflow 比 "启动 fullstack-agent" 直观）
    │   │   ✅ 工作流封装（6 阶段逻辑封装在命令中）
    │   │   ✅ 降级策略（命令内定义降级方案）
    │   │   ✅ 版本控制（命令文件可版本控制、团队共享）
    │   │   ✅ 智能路由（命令内部自动选择执行方式）
    │   │
    │   ├─ 劣势：
    │   │   ⚠️ 多一层抽象
    │   │   ⚠️ 需要维护命令文档
    │   │
    │   └─ 推荐度：⭐⭐⭐⭐⭐（强烈推荐）
    │
    ├─ 方案 B：去除命令层
    │   │
    │   ├─ 优势：
    │   │   ✅ 架构简化
    │   │   ✅ 灵活性高
    │   │
    │   ├─ 劣势（致命缺陷）：
    │   │   ❌ 违反渐进式披露原则
    │   │   ❌ 用户认知负担增加（需理解 Subagents vs Agent Teams）
    │   │   ❌ 工作流逻辑分散（6 阶段逻辑分散在主代理提示词中）
    │   │   ❌ 失去版本控制（无法版本控制和团队共享）
    │   │   ❌ 降级策略缺失（无法预定义降级方案）
    │   │   ❌ 成本预估困难（用户无法提前知道成本）
    │   │
    │   ├─ 风险：
    │   │   🔴 RISK-1（高）：用户认知负担增加
    │   │   🔴 RISK-3（高）：成本失控
    │   │
    │   └─ 推荐度：⭐（不推荐）
    │
    └─ 方案 C：混合方案（命令层可选）
        │
        ├─ 优势：
        │   ✅ 灵活性（用户可选择使用命令或直接描述）
        │   ✅ 渐进式披露（新手用命令，高级用户直接描述）
        │
        ├─ 劣势：
        │   ⚠️ 维护成本高（需维护两套路由逻辑）
        │   ⚠️ 一致性风险（命令路由和主代理决策可能不一致）
        │   ⚠️ 用户困惑（两种方式可能导致用户不知道选哪个）
        │
        └─ 推荐度：⭐⭐⭐（可作为长期演进方向）

┌─────────────────────────────────────────────────────────┐
│ 最终推荐：方案 A - 保留并优化命令层                        │
│                                                          │
│ 核心理由：                                                │
│ 1. 符合渐进式披露原则（SC-1）                             │
│ 2. 提供用户友好抽象（HC-6）                               │
│ 3. 去除会导致高风险（RISK-1）                             │
│ 4. 支持版本控制和团队协作（SC-5）                         │
│ 5. 可实现智能路由和成本预估（SC-3）                       │
└─────────────────────────────────────────────────────────┘
```

---

## 5. 混合策略执行流程图

```
┌─────────────────────────────────────────────────────────┐
│                  混合策略三阶段模型                        │
└─────────────────────────────────────────────────────────┘

阶段 1：侦察（Subagents）
┌─────────────────────────────────────────────────────────┐
│ 目标：低成本并行扫描，产出约束集                           │
├─────────────────────────────────────────────────────────┤
│ 执行方式：                                                │
│   ├─ Subagent A：代码库扫描                               │
│   ├─ Subagent B：依赖分析                                 │
│   └─ Subagent C：风险识别                                 │
│                                                          │
│ 输出：                                                    │
│   └─ .claude/spec/constraints/xxx.md                    │
│      （约束集：硬约束、软约束、依赖、风险）                │
│                                                          │
│ 成本：1x（多个 Subagent 并行，结果压缩回传）              │
│ 时间：5-10 分钟                                           │
└─────────────────────────────────────────────────────────┘
    │
    │ 数据传递：文件 → 主代理读取
    ▼
阶段 2：规划（主代理或 Subagent）
┌─────────────────────────────────────────────────────────┐
│ 目标：将约束集转化为零决策可执行计划                       │
├─────────────────────────────────────────────────────────┤
│ 执行方式：                                                │
│   ├─ 读取约束集                                           │
│   ├─ 调用外部模型（Codex + Gemini）分析                   │
│   └─ 生成零决策计划                                       │
│                                                          │
│ 输出：                                                    │
│   └─ .claude/spec/plans/xxx.md 或                       │
│      .claude/team-plan/xxx.md                           │
│      （计划：子任务、文件范围、依赖、并行分组）            │
│                                                          │
│ 成本：1x（Subagent 或主代理）                             │
│ 时间：5-10 分钟                                           │
└─────────────────────────────────────────────────────────┘
    │
    │ 数据传递：文件 → Agent Teams 读取
    ▼
阶段 3：突击（Agent Teams）
┌─────────────────────────────────────────────────────────┐
│ 目标：并行实施，实时对齐接口                               │
├─────────────────────────────────────────────────────────┤
│ 执行方式：                                                │
│   ├─ Lead 创建 Team                                      │
│   ├─ spawn Builder 1（后端 API）                         │
│   ├─ spawn Builder 2（前端组件）                         │
│   ├─ spawn Builder 3（测试用例）                         │
│   └─ Builders 实时通信对齐接口                            │
│                                                          │
│ 输出：                                                    │
│   └─ 项目源代码变更                                       │
│                                                          │
│ 成本：~7x（每个 Builder 独立上下文 + 消息开销）           │
│ 时间：10-20 分钟                                          │
└─────────────────────────────────────────────────────────┘
    │
    │ 数据传递：代码变更 → Subagents 读取
    ▼
阶段 4：扫尾（Subagents）
┌─────────────────────────────────────────────────────────┐
│ 目标：独立验证审查，pass/fail 判定                        │
├─────────────────────────────────────────────────────────┤
│ 执行方式：                                                │
│   ├─ Subagent D：集成测试                                 │
│   ├─ Subagent E：安全审计                                 │
│   └─ Subagent F：性能检查                                 │
│                                                          │
│ 输出：                                                    │
│   └─ .claude/spec/reviews/xxx.md                        │
│      （审查报告：pass/fail、问题清单、修复建议）          │
│                                                          │
│ 成本：1x（多个 Subagent 并行，结果压缩回传）              │
│ 时间：5-10 分钟                                           │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 总成本：1x + 1x + 7x + 1x = 10x                          │
│ 对比纯 Agent Teams：7x * 4 阶段 = 28x                    │
│ 成本节省：64%                                             │
│                                                          │
│ 总时间：25-50 分钟                                        │
│ 质量：高（关键阶段使用 Agent Teams）                      │
└─────────────────────────────────────────────────────────┘
```

---

## 6. 成本对比可视化

```
┌─────────────────────────────────────────────────────────┐
│              Token 成本对比（相对于基准 1x）               │
└─────────────────────────────────────────────────────────┘

主代理直接执行
█ 1x
适用：简单任务、无代码变更

Subagents
█ 1x
适用：独立任务、低耦合

Agent Teams
███████ 7x
适用：需要实时协作、接口对齐

混合策略（侦察-突击-扫尾）
██ 2-3x
适用：复杂任务、分阶段执行

纯 Agent Teams（4 阶段）
████████████████████████████ 28x
不推荐：成本过高

┌─────────────────────────────────────────────────────────┐
│ 成本优化建议：                                            │
│ 1. 简单任务：主代理或 Subagents（1x）                    │
│ 2. 复杂任务：混合策略（2-3x）                             │
│ 3. 避免：纯 Agent Teams 多阶段（28x）                     │
│ 4. 成本节省：混合策略比纯 Agent Teams 节省 64%            │
└─────────────────────────────────────────────────────────┘
```

---

## 7. 用户认知负担对比

```
┌─────────────────────────────────────────────────────────┐
│              用户认知负担评估（1-5 星）                    │
└─────────────────────────────────────────────────────────┘

方案 A：保留命令层
认知负担：⭐（最低）
├─ 用户只需知道命令名称和用途
├─ 无需理解 Subagents vs Agent Teams 差异
├─ 命令内部自动选择执行方式
└─ 执行前显示成本预估

方案 B：去除命令层
认知负担：⭐⭐⭐⭐⭐（最高）
├─ 用户需要理解 Subagents vs Agent Teams 差异
├─ 用户需要描述任务特征以帮助主代理决策
├─ 用户需要理解通信拓扑、进程模型、成本差异
└─ 无成本预估，可能导致预算超支

方案 C：混合方案
认知负担：⭐⭐⭐（中等）
├─ 用户需要选择使用命令还是直接描述
├─ 高级用户可直接描述，新手使用命令
└─ 两种方式可能导致困惑

┌─────────────────────────────────────────────────────────┐
│ 推荐：方案 A - 保留命令层                                 │
│ 理由：最低认知负担，符合渐进式披露原则                     │
└─────────────────────────────────────────────────────────┘
```

---

## 8. 快速参考：何时使用哪种模式

```
┌─────────────────────────────────────────────────────────┐
│                  快速决策参考表                           │
└─────────────────────────────────────────────────────────┘

场景 1：修改单个配置文件
├─ 模式：主代理直接执行
├─ 成本：1x
└─ 示例：更新 package.json

场景 2：添加单个 API 端点
├─ 模式：主代理规划 → Subagent 执行
├─ 成本：1x
└─ 示例：ccg:plan → ccg:execute

场景 3：技术可行性分析
├─ 模式：Subagent 规划（调用外部模型）→ 主代理整合
├─ 成本：1x
└─ 示例：ccg:analyze

场景 4：独立模块并行开发
├─ 模式：Subagents 并行执行
├─ 成本：1x
└─ 示例：3 个独立功能模块

场景 5：前后端 API 联调
├─ 模式：主代理规划 → Agent Teams 执行
├─ 成本：规划 1x + 执行 7x
└─ 示例：ccg:team-plan → ccg:team-exec

场景 6：OAuth 集成（复杂全栈）
├─ 模式：混合策略（侦察-突击-扫尾）
├─ 成本：2-3x
└─ 示例：ccg:workflow

场景 7：复杂调试（多假设验证）
├─ 模式：Agent Teams（Teammates 互相挑战）
├─ 成本：7x
└─ 示例：ccg:debug（升级到 Agent Teams）

场景 8：多模块架构重构
├─ 模式：混合策略（分阶段执行）
├─ 成本：2-3x
└─ 示例：ccg:workflow（6 阶段）
```

---

## 总结

### 核心决策原则

1. **优先考虑成本**：能用 Subagents 就不用 Agent Teams
2. **按需使用协作**：只在需要实时通信时使用 Agent Teams
3. **混合策略最优**：复杂任务分阶段执行，平衡成本与质量
4. **保留命令层**：提供用户友好抽象，符合渐进式披露原则

### 关键约束

- **HC-1**：通信拓扑差异决定模式选择
- **HC-3**：Token 成本差异（7x）必须考虑
- **SC-1**：渐进式披露原则要求保留命令层
- **SC-4**：混合策略是成本与质量的最优平衡

### 推荐方案

**提案 A：保留并优化命令层**
- 命令层智能路由
- 任务规划职责动态分配
- 混合策略标准化
- 成本预估和动态降级

---

**文件状态**：✅ 完成
**下一步**：使用本决策树指导架构优化实施
